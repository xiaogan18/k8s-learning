# Kubernetes objects

## Overview 
Kubernetes objects are persistent entities in the Kubernetes system, they represent the state of your cluster. You can describe your cluster desired state by creating a object, Kubernetes system will constantly work to ensure that object exists. To work with objects you'll need to use `Kubernetes API`, such as `kubectl` command-line interface.

## Object spec and status 
Almost every Kubernetes objects include two main object fields: `spec` and `status`. `spec` is defined by yourself when create objects, for describing your application `desired state`. The `status` supplied and updated by Kubernetes system and components, for describing current status of you application.

### A deployment object 
In Kubernetes system, a deployment object represent a application running on your cluster, you must provide the object spec that describe its desired state, as well as some basic information and additionals. Kubernetes API only accept `json` data but most often use `kubectl` by providing a `.yaml` file, `kubectl` convert it to `json` when making the API request.<br>
Here is an example `.yaml` file defined deployment object, shows the required fields and object spec:
```yaml
apiVersion: apps/v1 # [required] Which version of the Kubernetes API you're using to create this object, for versions before 1.9.0 use apps/v1beta2
kind: Deployment # [required] What kind of object you want to create
metadata: # Data that helps uniquely identify the object, including a name string, UID, and optional namespace
  name: nginx-deployment
spec: # What state you desire for the object
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```
Can deploy application by using `kubectl apply` command, for example:
```shell 
kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
```
The output similar to this:
```
deployment.apps/nginx-deployment created
```

## Object name and ID 
Each object has a name that is unique for that type of resource, also every object has a `UID` that is unique across the whole cluster. One name should appear once within the same `namespace`, but you can have same name resource in different type such as `Pod` and `Deployment`.

### Name 
Name is unique for a given kind, it can be refered in a resource URL  such as `/api/v1/pods/some-name`, client can easily locate resources by using name. Names define should abide by particularly regulations, for example the name can not be '.' or '..' and '%' or '/' can't be contained, go to official web site see more details.

### UID 
UID is a string generated by Kubernetes system to uniquely identify objects, every object created over the whole lifetime for distinguish between historical occurrences of similar entities. UID standardized as ISO/IEC 9834-8 and as ITU-T X.667.

## Namespaces
Namespaces are intended for dividing multiple applications of different projects or teams, its allowed multiple virtual cluster running at single physical cluster. There are several default namespaces created by Kubernetes system and also you can create you own namespace, use command below to view current namespaces in you cluster:
```shell 
kubectl get namespace 
```
Usually output as below:
```
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
Kubernetes starts with those default namespaces:
- `default` The default namespace if omit.
- `kube-system` The namespace for objects create by Kubernetes system.
- `kube-public` The namespace is created automatically and is readable by all users.
- `kube-node-lease` This namespace for the lease objects associated with each node which improves the performance of the node heartbeats as the cluster scales.

### Set namespace for request 
To set namespace for a request, use `--namespace` or `-n` flag, for example:
```shell 
kubectl run nginx --image nginx --namespace some-namespace
kubectl get pods -n some-namespace
```
Most resources are in some namespaces or even no namespace, use `--namespaced` flag to view:
```shell
# In a namespace
kubectl api-resources --namespaced=true

# Not in a namespace
kubectl api-resources --namespaced=false
```
If you want search across all namespaces, use `--all-namespace` flag
```shell 
kubectl get pods --all-namespaces
```

## Labels
Labels are key/value pairs attached to object, intended to specify identifying attributes of objects that are meaningful and relevant to users. It can be used to organize and select subsets, can define at creation time and modify anytime. Each key must be unique in a object, example below:
```json
"metadata": {
  "labels": {
    "key1" : "value1",
    "key2" : "value2"
  }
}
```
### Label selector 
Labels do not support uniqueness in Kubernetes system, in general, multiple objects carry with same labels. Via label selector we can identify a set of objects, labels separate objects as different groups. Currently the API providing two types of selector:
- `equality-based` Filtering with keys and values, support three kind of operators `=`, `==` and `!=`. There is example for matching node with the label `accelerator=nvidia-tesla-p100`
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: cuda-test
spec:
  containers:
    - name: cuda-test
      image: "k8s.gcr.io/cuda-vector-add:v0.1"
      resources:
        limits:
          nvidia.com/gpu: 1
  nodeSelector:
    accelerator: nvidia-tesla-p100
```
- `set-based` Filtering with keys according to a set of values, three kind of operators are supported: `in`, `not in` and `exist`. Examples:
```
environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
```
The two selector can be used mixed, for example: `partition in (customerA, customerB),environment!=qa`.

### API
Use `kubectl` flag `-l` invoke API to filtering objects, two kind of selector requirements are permitted.
- use `equality-based`
```shell 
kubectl get pods -l environment=production,tier=frontend
```
- use `set-based`
```shell
kubectl get pods -l 'environment in (production),tier in (frontend)'
```
- use mixed
```shell
kubectl get pods -l 'environment in (production, qa),tier!=frontend'
```

## Annotations
Kubernetes system allow you define arbitrary non-identifying metadata to objects, for retrieving by clients such as tools or library. It do not supported identify and select objects, only for reading, and looser limitation for definition.  For examples:
```json
"metadata": {
  "annotations": {
    "key1" : "value1",
    "key2" : "value2"
  }
}
```

## Field selectors
Filed selector allow you select resources by key-value matching, for example queries:
```
metadata.name=my-service
metadata.namespace!=default
status.phase=Pending
```
Use `kubectl` flag `--filed-selector` to search resources:
```shell 
kubectl get pods --field-selector status.phase=Running
```

## Recommend labels 
In order to take full advantage of using labels, Kubernetes recommend define labels as standard below:
|Key|Description|
|---|---|
| app.kubernetes.io/name | The name of application |
| app.kubernetes.io/instance | The unique name of application instance |
| app.kubernetes.io/version | The version of application |
| app.kubernetes.io/component | The component within architecture |
| app.kubernetes.io/part-of | The name of higher application if this one is a part of  |
| app.kubernetes.io/managed-by | The tool name used to manage the application |